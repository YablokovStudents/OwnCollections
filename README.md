### Для чего создан данный репозиторий?
В данном репозитории студентам необходимо выполнять задачи на тему «Создание аналогов базовых коллекции в java».
Для помощи студентам куратор в одной из корневых веток (например, develop) реализует минимальные наброски (скелет) java-приложений, помогающие студентам при выполнении практических заданий во время летней практики в АО "Сбербанк-Технологии".

---

### Задачи на тему «Создание аналогов базовых коллекции в java»
В рамках данного курса необходимо реализовать собственные коллекции.

---

### Collection

Создать интерфейс `Collection`, содержащий методы:

* `int size()` – количество элементов в списке;
* `boolean isEmpty()` – проверка пуст ли список;
* `boolean contains(Object item)` – проверка наличия элемента item в коллекции;
* `boolean add(Object item)` – вставка элемента item в конец коллекции;
* `boolean remove(Object item)` — удаление элемента item из коллекции (если элемент встречается несколько раз, то должны быть удалены всех вхождения элемента в коллекцию);
* `void clear()` — очищение коллекции (удаление всех элементов).

---

### List

Создать интерфейс `List`, который расширяет интерфейс `Collection`, а также добавляет собственные методы:

* `void add(int index, Object item)` — вставка элемента item на позицию index, при этом список раздвигается (все элементы, начиная с позиции index, увеличивают свой индекс на 1, т.е. сдвигаются на один элемент вправо);
* `void set(int index, Object item)` — замена элемента, находящегося на позиции index объектом item;
* `Object get(int index)` — получение объекта, находящегося на позиции index (в случае отсутствия в коллекции элемента на такой позиции выбрасывается `IndexOutOfBoundsException`);
* `int indexOf(Object item)` — получение индекса первого появления элемента item в списке, либо `-1` в случае отсутствия;
* `int lastIndexOf(Object item)` — получение индекса последнего появления элемента item в списке, либо `-1` в случае отсутствия;
* `void remove(int index)` — удаление элемента, находящегося на позиции index (в случае отсутствия в коллекции элемента на такой позиции выбрасывается `IndexOutOfBoundsException`);
* `List subList(int from, int to)` — получение нового списка, представляющего собой часть данного, начиная с позиции from до позиции to-1 включительно (в случае выхода за границы коллекции выбрасывается `IndexOutOfBoundsException`).

---

### ArrayList

Создать класс `ArrayList`, который будет реализовывать наш интерфейс `List`, инкапсулируя в себе обычный массив, на основе следующего принципа:

При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево, при этом реальный размер массива (его емкость, capacity) не изменяется.  

Если при добавлении элемента, оказывается, что массив полностью заполнен, будет создан новый массив размером в полтора раза больше предыдущего, в него будут помещены все элементы из старого массива + новый, добавляемый элемент.

#### Подсказка:

*В качестве инкапсулируемого массива следует использовать обычный массив из объектов `Object[]`, который при создании коллекции содержит, например, 10 `null` объектов, т.е. заранее резервирует место для хранения будущих объектов.
Иными словами, размер массива `!=` количеству реальных объектов, поэтому вам придется завести отдельное поля для хранения количества элементов в массиве.*

*При достижении правой границы инкапсулируемого массива его необходимо заменить более емким, например, посредством увеличения его размера в полтора раза.*

*Для увеличения размера инкапсулируемого в коллекции массива можно воспользоваться следующей формулой: `(n * 3) / 2 + 1`.*
  
*Стоит заметить, что данную формулу можно улучшить за счет бинарных операций.*

---

### Deque

Создать интерфейс `Deque`, который расширяет интерфейс `Collection`, а также добавляет собственные методы:

* `void addFirst(Object item)` – добавление элемента в начало коллекции;
* `void addLast(Object item)` – добавление элемента в конец коллекции;
* `Object getFirst()` – получение первого элемента коллекции, не удаляя его из самой коллекции (в случае отсутствия элементов в коллекции бросается `NoSuchElementException`);
* `Object getLast()` – получение последнего элемента коллекции, не удаляя его из самой коллекции (в случае отсутствия элементов в коллекции бросается `NoSuchElementException`);
* `Object pollFirst()` - получение первого элемента коллекции, удаляя его из самой коллекции (в случае отсутствия элементов в коллекции возвращается `null`);
* `Object pollLast()` - получение последнего элемента коллекции, удаляя его из самой коллекции (в случае отсутствия элементов в коллекции возвращается `null`);
* `Object removeFirst()` – удаление элемента из начала коллекции (возвращается удаленный элемент, а в случае отсутствия элементов в коллекции выбрасывается исключение `NoSuchElementException`);
* `Object removeLast()` – удаление элемента из конца коллекции (возвращается удаленный элемент, а в случае отсутствия элементов в коллекции выбрасывается исключение `NoSuchElementException`).

---

### LinkedList

Создать класс `LinkedList`, реализующий наши интерфейсы List и Deque посредством классического двусвязного списка, основанного на объектах с ссылками между ними.

#### Подсказка:

Пример класса, который можно использовать в качестве узла в двусвязном списке:

```
class Node {
    Object item;
    Node next;
    Node prev;
}
```

---

### Iterable

Расширить (`extends`) интерфейс `Collection` стандартным интерфейсом `java.lang.Iterable`, вследствие чего станет необходимо реализовать соответствующие методы в классах-наследниках от `Collection`.