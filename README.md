### Для чего создан данный репозиторий?
В данном репозитории студентам необходимо выполнять задачи на тему «Создание аналогов базовых коллекции в java».
Для помощи студентам куратор в одной из корневых веток (например, develop) реализует минимальные наброски (скелет) java-приложений, помогающие студентам при выполнении практических заданий во время летней практики в АО "Сбербанк-Технологии".

---

### Задачи на тему «Создание аналогов базовых коллекции в java»
В рамках данного курса необходимо реализовать собственные коллекции.

---

### Collection

Создать интерфейс `Collection`, содержащий методы:

* `int size()` – количество элементов в списке;
* `boolean isEmpty()` – проверка пуст ли список;
* `boolean contains(Object item)` – проверка наличия элемента item в коллекции;
* `boolean add(Object item)` – вставка элемента item в конец коллекции;
* `boolean remove(Object item)` — удаление элемента item из коллекции (если элемент встречается несколько раз, то должны быть удалены всех вхождения элемента в коллекцию);
* `void clear()` — очищение коллекции (удаление всех элементов).

---

### List

Создать интерфейс `List`, который расширяет интерфейс `Collection`, а также добавляет собственные методы:

* `void add(int index, Object item)` — вставка элемента item на позицию index, при этом список раздвигается (все элементы, начиная с позиции index, увеличивают свой индекс на 1, т.е. сдвигаются на один элемент вправо);
* `void set(int index, Object item)` — замена элемента, находящегося на позиции index объектом item;
* `Object get(int index)` — получение объекта, находящегося на позиции index (в случае отсутствия в коллекции элемента на такой позиции выбрасывается `IndexOutOfBoundsException`);
* `int indexOf(Object item)` — получение индекса первого появления элемента item в списке, либо `-1` в случае отсутствия;
* `int lastIndexOf(Object item)` — получение индекса последнего появления элемента item в списке, либо `-1` в случае отсутствия;
* `Object remove(int index)` — удаление элемента, находящегося на позиции index (возвращается удаленный элемент, а в случае отсутствия элементов в коллекции выбрасывается исключение `IndexOutOfBoundsException`);
* `List subList(int from, int to)` — получение нового списка, представляющего собой часть данного, начиная с позиции from до позиции to-1 включительно (в случае выхода за границы коллекции выбрасывается `IndexOutOfBoundsException`).

---

### ArrayList

Создать класс `ArrayList`, который будет реализовывать наш интерфейс `List`, инкапсулируя в себе обычный массив, на основе следующего принципа:

При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево, при этом реальный размер массива (его емкость, capacity) не изменяется.  

Если при добавлении элемента, оказывается, что массив полностью заполнен, будет создан новый массив размером в полтора раза больше предыдущего, в него будут помещены все элементы из старого массива + новый, добавляемый элемент.

#### Подсказка:

*В качестве инкапсулируемого массива следует использовать обычный массив из объектов `Object[]`, который при создании коллекции содержит, например, 10 `null` объектов, т.е. заранее резервирует место для хранения будущих объектов.
Иными словами, размер массива `!=` количеству реальных объектов, поэтому вам придется завести отдельное поля для хранения количества элементов в массиве.*

*При достижении правой границы инкапсулируемого массива его необходимо заменить более емким, например, посредством увеличения его размера в полтора раза.*

*Для увеличения размера инкапсулируемого в коллекции массива можно воспользоваться следующей формулой: `(n * 3) / 2 + 1`.*
  
*Стоит заметить, что данную формулу можно улучшить за счет бинарных операций.*

---

### Deque

Создать интерфейс `Deque`, который расширяет интерфейс `Collection`, а также добавляет собственные методы:

* `void addFirst(Object item)` – добавление элемента в начало коллекции;
* `void addLast(Object item)` – добавление элемента в конец коллекции;
* `Object getFirst()` – получение первого элемента коллекции, не удаляя его из самой коллекции (в случае отсутствия элементов в коллекции бросается `NoSuchElementException`);
* `Object getLast()` – получение последнего элемента коллекции, не удаляя его из самой коллекции (в случае отсутствия элементов в коллекции бросается `NoSuchElementException`);
* `Object pollFirst()` - получение первого элемента коллекции, удаляя его из самой коллекции (в случае отсутствия элементов в коллекции возвращается `null`);
* `Object pollLast()` - получение последнего элемента коллекции, удаляя его из самой коллекции (в случае отсутствия элементов в коллекции возвращается `null`);
* `Object removeFirst()` – удаление элемента из начала коллекции (возвращается удаленный элемент, а в случае отсутствия элементов в коллекции выбрасывается исключение `NoSuchElementException`);
* `Object removeLast()` – удаление элемента из конца коллекции (возвращается удаленный элемент, а в случае отсутствия элементов в коллекции выбрасывается исключение `NoSuchElementException`).

---

### LinkedList

Создать класс `LinkedList`, реализующий наши интерфейсы List и Deque посредством классического двусвязного списка, основанного на объектах с ссылками между ними.

#### Подсказка:

Пример класса, который можно использовать в качестве узла в двусвязном списке:

```
class Node {
    Object item;
    Node next;
    Node prev;
}
```

---

### Iterable

Расширить (`extends`) интерфейс `Collection` стандартным интерфейсом `java.lang.Iterable`, вследствие чего станет необходимо реализовать соответствующие методы в классах-наследниках от `Collection`.

---

### Map

Создать интерфейс `Map`, содержащий методы:

* `int size()` – количество элементов в списке;
* `boolean isEmpty()` – проверка пуст ли список;
* `boolean containsKey(Object key)` – проверка наличия ключа равного `key` в рамках какой-либо из хранимых в `Map` пар `<key, value>`;
* `boolean containsValue(Object value)` – проверка наличия значения равного `value` в рамках хотя бы одной из хранимых в `Map` пар `<key, value>`;
* `Object get(Object key)` – получение значения (которое могло быть `null`), связанного с ключом равным `key` (если значение не было найдено, то возвращается `null`);
* `Object put(Object key, Object value)` – вставка пары `<key, value>` в `Map` (если в `Map` уже присутствует пара `<key, value>` с идентичным key, то в рамках этой пары происходит замена `value`).
Возвращается значение замененного `value` (который мог быть `null`), либо `null`, если связанного со вставляемым `key` значения ранее не было;
* `Object remove(Object key)` — удаление из `Map` пары `<key, value>`, в рамках которой ключ равен `key`.
Возвращается значение `value` (который мог быть `null`), либо `null`, если связанного с удаляемым `key` значения ранее не было;
* `void clear()` — очищение `Map` (удаление всех пар `<key, value>`);
* `Collection values()` — получение коллекции, состоящей из значений, которые хранятся в `Map` в рамках пар `<key, value>`;
* `Collection keySet()` — получение коллекции, состоящей из ключей, которые хранятся в `Map` в рамках пар `<key, value>`;
* `Collection entrySet()` — получение коллекции, состоящей из пар `<key, value>`, которые хранятся в рамках `Map`.

_Примечание: в текущем описании `keySet` и `entrySet` возвращают интерфейс `Collection`, а не `Set`, т.к. интерфейс `Set` в рамках ряда данных заданий не реализовывался._

---

### HashMap

Создать класс `HashMap`, который будет реализовывать наш интерфейс `Map`, инкапсулируя в себе следующие особенности реализации:

* выделяется массив (`buckets`), элементами которого являются `LinkedList` (при работе с ним достаточно ограничиться интерфейсом `Deque`):
  * элементы массива принято называть корзинами (`entry`);
  * с точки зрения оптимизаций размер массива удобно делать степенью числа 2 (см. далее алгоритм рассчета номера корзины);
* вставка пары ключ значение (`put(key, value)`) реализована следующим образом:
  1. рассчитывается номер корзины: `int bucketNumder = key.hashCode() % buckets.length()`;
  2. происходит получение списка: `LinkedList list = buckets[bucketNumber]`;
  3. происходит обход `LinkedList` в поисках пары `<key, value>`, у которой ключ равен `key` из добавляемой пары:
     1. если пара найдена, то в рамках нее происходит замена `value`;
     2. если пара не найдена, то происходит вставка пары в конец списка: `LinkedList.addLast(new Entry(key, value))`;
* получение значения по ключу (`Object get(key)`) реализовано следующим образом:
  1. рассчитывается номер корзины: `int bucketNumder = key.hashCode() % buckets.length()`;
  2. происходит получение списка: `LinkedList list = buckets[bucketNumber]`;
  3. происходит обход `LinkedList` в поисках пары `<key, value>`, у которой ключ равен `key` из добавляемой пары:
     1. если пара найдена, то происходит возвращение из неё `value` (который мог быть `null`);
     2. если пара не найдена, то происходит возвращение `null`.

---

### TreeMap

Создать класс `TreeMap`, который будет реализовывать наш интерфейс `Map`, инкапсулируя в себе [двоичное дерево](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0).

После завершения реализации двоичного дерева необходимо его доработать до [красно-черного дерева](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE).